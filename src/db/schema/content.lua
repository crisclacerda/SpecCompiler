---Content schema tables for SpecCompiler.
-- Defines specifications, spec_objects, spec_floats, spec_relations,
-- spec_views, and spec_attribute_values.

local M = {}

M.SQL = [=[
--------------------------------------------------------------------------------
-- CONTENT TABLES
--
-- These tables store actual content parsed from specification documents.
-- Each row represents an instance of a type defined in the TYPE SYSTEM tables.
-- This is the "data" layer - where requirements, tests, figures live.
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- 8. SPECIFICATIONS
-- Root-level specification documents.
-- Each .md file processed becomes one row here.
-- Parent for all spec_objects, spec_floats, spec_relations, spec_views.
-- Uses filename slug as TEXT PRIMARY KEY (natural key, not SHA1).
--------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS specifications (
  -- Unique specification ID (filename slug, e.g., "requirements" from "requirements.md")
  identifier TEXT PRIMARY KEY,

  -- Absolute path to the root .md file
  -- Used for include resolution and file change detection
  root_path TEXT NOT NULL UNIQUE,

  -- Human-readable document title (from H1 header)
  long_name TEXT,

  -- Specification type (SRS, SDD, SVC, etc.)
  -- FK to spec_specification_types.identifier
  type_ref TEXT,

  -- Project identifier from @PID syntax in H1 header
  -- E.g., "SRS-001" from "# SRS: My Document @SRS-001"
  pid TEXT,

  -- Rendered H1 header as Pandoc AST JSON
  -- Generated by specification type handler during TRANSFORM phase
  -- Used to reconstruct document during EMIT phase
  -- Schema: [{t:'Header',c:[1,['id',[],[]],[{t:'Str',c:'Title'}]]}]
  header_ast JSON,

  -- Body content blocks between H1 header and first H2 (or end of document)
  -- Stores Pandoc AST JSON for root-level content (views, paragraphs, etc.)
  -- that sits under the specification but outside any spec_object.
  -- Used by assembler to include spec-level body content in output.
  body_ast JSON
);

--------------------------------------------------------------------------------
-- 9. SPEC OBJECTS
-- Individual objects within a specification (requirements, tests, sections).
-- Created from H2+ headers in markdown.
-- Core entity for traceability and coverage analysis.
--------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS spec_objects (
  -- Opaque internal primary key (auto-assigned by SQLite)
  id INTEGER PRIMARY KEY,

  -- SHA1 checksum for change detection (not a key)
  content_sha TEXT,

  -- Parent specification
  -- FK to specifications.identifier
  specification_ref TEXT NOT NULL,

  -- Object type (HLR, FD, VC, TP, SECTION, etc.)
  -- FK to spec_object_types.identifier
  -- Determines rendering, validation rules, and allowed attributes
  type_ref TEXT NOT NULL,

  -- Source file path (relative to project root)
  -- May differ from specification root if using includes
  from_file TEXT NOT NULL,

  -- Sequence number within file (0-indexed)
  -- Used for ordering objects in document order
  file_seq INTEGER NOT NULL,

  -- Project identifier from @PID syntax
  -- E.g., "REQ-001" from "## HLR: My Requirement @REQ-001"
  -- Used for cross-references and traceability
  -- NULL if no PID provided (auto-generated in ANALYZE phase)
  pid TEXT,

  -- PID prefix extracted from @PREFIX-NN syntax (e.g., "HLR", "VC")
  -- NULL if PID is numeric-only, not provided, or doesn't follow pattern
  pid_prefix TEXT,

  -- PID sequence number extracted from @PREFIX-NN or @NN syntax
  -- E.g., 1 from "@HLR-001", 42 from "@42"
  -- NULL if no PID provided or PID doesn't have numeric suffix
  pid_sequence INTEGER,

  -- Boolean (0/1): Was this PID auto-generated?
  -- 1 = PID was not provided by author, generated from sibling pattern
  -- 0 = PID was explicitly provided via @PID syntax
  pid_auto_generated INTEGER DEFAULT 0,

  -- Plain text title extracted from header
  -- E.g., "My Requirement" from "## HLR: My Requirement @REQ-001"
  -- Mandatory: every object must have a title
  title_text TEXT NOT NULL,

  -- Unified label for # selector resolution
  -- Format: {type_prefix_lower}:{title_slug}
  -- E.g., "hlr:my-requirement", "section:introduction"
  -- Used for cross-references via [label](#) syntax
  label TEXT,

  -- Heading level (2 for H2, 3 for H3, etc.)
  -- H1 is reserved for specification title
  level INTEGER,

  -- Start line number in source file (1-indexed)
  -- Used for error reporting and IDE integration
  start_line INTEGER,

  -- End line number in source file (exclusive)
  -- Line before the next object starts
  end_line INTEGER,

  -- Object body as Pandoc AST JSON
  -- Contains all content between this header and the next
  -- Schema: [{t:'Para',c:[...]}, {t:'BulletList',c:[...]}]
  -- Used to reconstruct object during EMIT phase
  ast JSON,

  -- Cached HTML5 rendering of ast (populated by reqif_xhtml EMIT handler)
  -- Used by ReqIF exporter for ReqIF.Text XHTML attribute values
  content_xhtml TEXT,

  FOREIGN KEY (specification_ref) REFERENCES specifications(identifier),
  FOREIGN KEY (type_ref) REFERENCES spec_object_types(identifier)
);

--------------------------------------------------------------------------------
-- 10. SPEC FLOATS
-- Numbered floating elements (figures, tables, charts, diagrams).
-- Created from code blocks with special syntax.
-- Can be referenced via #label syntax.
--------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS spec_floats (
  -- Opaque internal primary key (auto-assigned by SQLite)
  id INTEGER PRIMARY KEY,

  -- SHA1 checksum for change detection (not a key)
  content_sha TEXT,

  -- Parent specification
  -- FK to specifications.identifier
  specification_ref TEXT NOT NULL,

  -- Float type (FIGURE, TABLE, CHART, PLANTUML, etc.)
  -- FK to spec_float_types.identifier
  -- Determines rendering and numbering behavior
  type_ref TEXT NOT NULL,

  -- Source file path (relative to project root)
  from_file TEXT NOT NULL,

  -- Sequence number within file (0-indexed)
  -- Used for document-order positioning
  file_seq INTEGER NOT NULL,

  -- Start line number in source file (1-indexed)
  -- Used for error reporting and IDE integration
  start_line INTEGER,

  -- Unified label for # selector resolution
  -- Format: {type_prefix}:{user_label}
  -- E.g., "fig:architecture", "tbl:data-summary"
  -- Used in [label](#) syntax for cross-references
  label TEXT NOT NULL,

  -- Auto-assigned number within counter group
  -- E.g., 1, 2, 3 for Figures (shared across FIGURE, CHART, PLANTUML if same counter_group)
  number INTEGER,

  -- Caption text (e.g., "System Architecture Diagram")
  caption TEXT,

  -- Parsed attributes from code block as JSON (Pandoc attributes)
  -- E.g., {"width": "80%", "align": "center"}
  pandoc_attributes JSON,

  -- Original raw text content (code, table data, PlantUML source, etc.)
  -- Preserved for re-rendering and change detection
  raw_content TEXT,

  -- Original code block as Pandoc AST JSON (before processing)
  -- Schema: {t:'CodeBlock',c:[['id',['class'],[['attr','value']],'content']]}
  raw_ast JSON,

  -- Processed AST after external rendering (SVG for PlantUML, etc.)
  -- Replaces raw_ast in final output
  -- NULL until EMIT phase renders external content
  resolved_ast JSON,

  -- Parent object containing this float (typed FK, always an object)
  -- FK to spec_objects.id
  -- Used for scoped reference resolution (#label within same object)
  parent_object_id INTEGER,

  -- Scoped anchor for HTML linking
  -- Format: {parent_pid}-{float_label}
  -- E.g., "REQ-001-fig:diagram" for a figure in REQ-001
  anchor TEXT,

  -- Original syntax from code block class
  -- E.g., "list-table:req-summary", "plantuml:architecture"
  -- Preserved for debugging and re-parsing
  syntax_key TEXT,

  FOREIGN KEY (specification_ref) REFERENCES specifications(identifier),
  FOREIGN KEY (type_ref) REFERENCES spec_float_types(identifier),
  FOREIGN KEY (parent_object_id) REFERENCES spec_objects(id)
);

--------------------------------------------------------------------------------
-- 11. SPEC RELATIONS
-- Relationships between objects (traceability links).
-- Created from @PID and #label syntax in markdown links.
-- Foundation for traceability matrices and coverage reports.
--------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS spec_relations (
  -- Opaque internal primary key (auto-assigned by SQLite)
  id INTEGER PRIMARY KEY,

  -- SHA1 checksum for change detection (not a key)
  content_sha TEXT,

  -- Parent specification
  -- FK to specifications.identifier
  specification_ref TEXT NOT NULL,

  -- Source object containing the link (typed FK, always an object)
  -- FK to spec_objects.id
  source_object_id INTEGER NOT NULL,

  -- Target as written in markdown (before resolution)
  -- E.g., "REQ-001", "fig:diagram", "TEST-001"
  -- Preserved for error reporting if resolution fails
  target_text TEXT,

  -- Resolved target: spec_object (NULL if target is a float or unresolved)
  -- FK to spec_objects.id
  -- Populated during ANALYZE phase by relation_analyzer
  target_object_id INTEGER,

  -- Resolved target: spec_float (NULL if target is an object or unresolved)
  -- FK to spec_floats.id
  -- Populated during ANALYZE phase by relation_analyzer
  target_float_id INTEGER,

  -- Relation type (TRACES_TO, VERIFIES, SATISFIES, CITES, etc.)
  -- FK to spec_relation_types.identifier
  -- NULL = use default relation type
  type_ref TEXT,

  -- Boolean (0/1): Was this reference ambiguous (multiple matches)?
  -- Set during resolution if multiple floats matched the label
  is_ambiguous INTEGER DEFAULT 0,

  -- Source file where the link appeared
  from_file TEXT NOT NULL,

  -- Line number where the link appeared (1-indexed, 0 = unknown)
  link_line INTEGER DEFAULT 0,

  -- Attribute name containing the link (for type inference)
  -- E.g., "verifies", "traceability", "allocated_to"
  -- NULL for links in body text (not inside an attribute)
  -- Used with source_type for relation type inference:
  --   (source_type, source_attribute) → type_ref
  source_attribute TEXT,

  -- Link syntax selector ("@" or "#") preserved for type inference
  link_selector TEXT,

  FOREIGN KEY (specification_ref) REFERENCES specifications(identifier),
  FOREIGN KEY (source_object_id) REFERENCES spec_objects(id),
  FOREIGN KEY (target_object_id) REFERENCES spec_objects(id),
  FOREIGN KEY (target_float_id) REFERENCES spec_floats(id),
  FOREIGN KEY (type_ref) REFERENCES spec_relation_types(identifier)
);

--------------------------------------------------------------------------------
-- 12. SPEC VIEWS
-- Generated content blocks (TOC, LOF, LOT, abbreviation lists).
-- Created from special code blocks like ```toc or ```lof.
-- Materialized during TRANSFORM phase.
--------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS spec_views (
  -- Opaque internal primary key (auto-assigned by SQLite)
  id INTEGER PRIMARY KEY,

  -- SHA1 checksum for change detection (not a key)
  content_sha TEXT,

  -- Parent specification
  -- FK to specifications.identifier
  specification_ref TEXT NOT NULL,

  -- View type (TOC, LOF, LOT, ABBREV, etc.)
  -- FK to spec_view_types.identifier
  -- Determines materialization strategy
  view_type_ref TEXT NOT NULL,

  -- Source file path
  from_file TEXT NOT NULL,

  -- Sequence number within file (0-indexed)
  file_seq INTEGER NOT NULL,

  -- Start line number in source file (1-indexed)
  -- Used for error reporting and IDE integration
  start_line INTEGER,

  -- Original code block as Pandoc AST JSON (before processing)
  raw_ast JSON,

  -- Materialized view as Pandoc AST JSON
  -- Generated during TRANSFORM phase by view_materializer
  -- E.g., TOC becomes a BulletList of links
  resolved_ast JSON,

  -- Pre-computed view data as JSON
  -- Structure varies by view type:
  -- TOC: [{level:2, pid:'REQ-001', title:'...', anchor:'...'}]
  -- LOF: [{number:1, type:'FIGURE', caption:'...', anchor:'...'}]
  -- Used for custom rendering and BI queries
  resolved_data JSON,

  FOREIGN KEY (specification_ref) REFERENCES specifications(identifier),
  FOREIGN KEY (view_type_ref) REFERENCES spec_view_types(identifier)
);

--------------------------------------------------------------------------------
-- 13. ATTRIBUTE VALUES (EAV Pattern)
-- Stores attribute values for spec_objects and spec_floats.
-- Entity-Attribute-Value design with typed columns for efficient queries.
-- Schema defined in spec_attribute_types table.
--------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS spec_attribute_values (
  -- Opaque internal primary key (auto-assigned by SQLite)
  id INTEGER PRIMARY KEY,

  -- SHA1 checksum for change detection (not a key)
  content_sha TEXT,

  -- Parent specification
  -- FK to specifications.identifier
  specification_ref TEXT NOT NULL,

  -- Owner: spec_object (NULL if owner is a float)
  -- FK to spec_objects.id
  owner_object_id INTEGER,

  -- Owner: spec_float (NULL if owner is an object)
  -- FK to spec_floats.id
  owner_float_id INTEGER,

  -- Attribute name (e.g., "status", "priority", "rationale")
  -- Must match spec_attribute_types.long_name for owner's type
  name TEXT NOT NULL,

  -- Original value as written in markdown (before type casting)
  -- Preserved for error reporting if casting fails
  raw_value TEXT,

  -- ============================================================
  -- TYPED VALUE COLUMNS (mutually exclusive based on datatype)
  -- Exactly one of these should be non-NULL after casting.
  -- Determined by spec_attribute_types.datatype_ref -> datatype_definitions.type
  -- ============================================================

  -- For STRING datatype
  string_value TEXT,

  -- For INTEGER datatype
  int_value INTEGER,

  -- For REAL datatype
  real_value REAL,

  -- For BOOLEAN datatype (0 = false, 1 = true)
  bool_value INTEGER,

  -- For DATE datatype (format: YYYY-MM-DD)
  -- Validated by proof view_object_invalid_date
  date_value TEXT,

  -- For ENUM datatype
  -- FK to enum_values.identifier
  -- Validated by proof view_object_invalid_enum
  enum_ref TEXT,

  -- ============================================================
  -- RICH CONTENT
  -- ============================================================

  -- For attributes with rich content (markdown formatting, links)
  -- Stores the Pandoc AST for the attribute value
  -- Used when string_value alone isn't sufficient
  ast JSON,

  -- ============================================================
  -- METADATA
  -- ============================================================

  -- Actual datatype used (STRING, INTEGER, REAL, BOOLEAN, DATE, ENUM, XHTML)
  -- Copied from datatype_definitions.type at casting time
  -- XHTML = rich content stored in ast column
  datatype TEXT NOT NULL,

  -- Cached HTML5 rendering of ast (populated by reqif_xhtml EMIT handler)
  -- Used by ReqIF exporter for XHTML-typed attribute values
  xhtml_value TEXT,

  FOREIGN KEY (specification_ref) REFERENCES specifications(identifier),
  FOREIGN KEY (owner_object_id) REFERENCES spec_objects(id),
  FOREIGN KEY (owner_float_id) REFERENCES spec_floats(id),
  FOREIGN KEY (enum_ref) REFERENCES enum_values(identifier)
);

--------------------------------------------------------------------------------
-- UNIQUENESS CONSTRAINTS
-- PID and label must be unique within a specification.
-- These UNIQUE indexes also serve as performance indexes for lookups.
--------------------------------------------------------------------------------

-- PID lookup per specification (partial index: NULL PIDs excluded)
-- Serves: WHERE specification_ref = ? AND pid = ? (relation resolver)
-- Uniqueness enforced by view_object_duplicate_pid proof in VERIFY phase, not by DB constraint.
CREATE INDEX IF NOT EXISTS idx_objects_spec_pid
    ON spec_objects(specification_ref, pid) WHERE pid IS NOT NULL;

-- Label uniqueness per specification for objects
-- Serves: WHERE specification_ref = ? AND label = ? (# selector resolution)
CREATE UNIQUE INDEX IF NOT EXISTS idx_objects_spec_label
    ON spec_objects(specification_ref, label) WHERE label IS NOT NULL;

-- Label lookup per specification for floats (not unique — duplicates detected by view_float_duplicate_label proof)
-- Serves: WHERE specification_ref = ? AND label = ? (# selector resolution)
CREATE INDEX IF NOT EXISTS idx_floats_spec_label
    ON spec_floats(specification_ref, label) WHERE label IS NOT NULL;

--------------------------------------------------------------------------------
-- PERFORMANCE INDEXES
--
-- Design principles:
--   1. Each index covers a specific hot query pattern (noted in comments)
--   2. Composite indexes include ORDER BY columns to avoid filesorts
--   3. Partial indexes reduce size for queries with known NULL filters
--   4. No redundant indexes — UNIQUE indexes above double as lookup indexes
--------------------------------------------------------------------------------

-- === spec_objects ===

-- Covering index for PID generation: sibling lookup by spec+type, ordered by file_seq
-- Serves: WHERE specification_ref = ? AND type_ref = ? ORDER BY file_seq
--         (pid_generator.lua, content queries)
CREATE INDEX IF NOT EXISTS idx_spec_objects_spec_type
    ON spec_objects(specification_ref, type_ref, file_seq);

-- Global PID fallback: cross-specification PID lookup
-- Serves: WHERE pid = ? (resolution.lua global PID search)
CREATE INDEX IF NOT EXISTS idx_spec_objects_pid
    ON spec_objects(pid) WHERE pid IS NOT NULL;

-- Document-order queries: TOC generation, AST assembly
-- Serves: WHERE specification_ref = ? ORDER BY file_seq
--         WHERE specification_ref = ? AND level <= ? ORDER BY file_seq
CREATE INDEX IF NOT EXISTS idx_spec_objects_spec_fileseq
    ON spec_objects(specification_ref, file_seq);

-- Parent object lookup: find enclosing object by line range (spec_relations init)
-- Serves: WHERE specification_ref = ? AND from_file = ? AND start_line <= ?
--         ORDER BY level DESC, start_line DESC LIMIT 1
CREATE INDEX IF NOT EXISTS idx_spec_objects_parent_lookup
    ON spec_objects(specification_ref, from_file, start_line, end_line, level);

-- Type-only lookups: EAV pivot views filter by type_ref without spec scope
-- Serves: WHERE type_ref = ? (eav_pivot views, proof views)
CREATE INDEX IF NOT EXISTS idx_spec_objects_type
    ON spec_objects(type_ref);

-- === spec_floats ===

-- Covering index for float numbering: partition by spec+type, ordered by file_seq
-- Serves: PARTITION BY specification_ref, type_ref ORDER BY file_seq
--         WHERE specification_ref = ? AND type_ref = ? (float queries)
CREATE INDEX IF NOT EXISTS idx_spec_floats_spec_type
    ON spec_floats(specification_ref, type_ref, file_seq);

-- Scoped float resolution: find float by label within parent object
-- Serves: WHERE parent_object_id = ? AND label = ? (scoped resolution, priority 1)
--         WHERE parent_object_id = ? (FTS indexing, float listing)
CREATE INDEX IF NOT EXISTS idx_spec_floats_parent_label
    ON spec_floats(parent_object_id, label);

-- Anchor-based lookups: HTML anchor resolution
-- Serves: WHERE anchor = ? (anchor resolution in emitter)
CREATE INDEX IF NOT EXISTS idx_spec_floats_anchor
    ON spec_floats(anchor) WHERE anchor IS NOT NULL;

-- Type-only lookups: float type queries without spec scope
-- Serves: WHERE type_ref = ? (float_base queries, proof views)
CREATE INDEX IF NOT EXISTS idx_spec_floats_type
    ON spec_floats(type_ref);

-- === spec_relations ===

-- Outbound relations: source object with optional type filter
-- Serves: WHERE source_object_id = ? [AND type_ref = ?]
--         JOIN ON source_object_id = obj.id AND type_ref = 'TRACES_TO'
CREATE INDEX IF NOT EXISTS idx_spec_relations_source
    ON spec_relations(source_object_id, type_ref);

-- Inbound relations to objects: target object with optional type filter
-- Serves: WHERE target_object_id = ? [AND type_ref = ?]
--         JOIN ON target_object_id = obj.id
CREATE INDEX IF NOT EXISTS idx_spec_relations_target_obj
    ON spec_relations(target_object_id, type_ref);

-- Inbound relations to floats: target float lookups
-- Serves: WHERE target_float_id = ? (float backrefs)
CREATE INDEX IF NOT EXISTS idx_spec_relations_target_flt
    ON spec_relations(target_float_id);

-- Unresolved relations: batch processing in relation analyzer (hot path)
-- Serves: WHERE specification_ref = ? AND target_object_id IS NULL
--           AND target_float_id IS NULL AND type_ref IS NULL
CREATE INDEX IF NOT EXISTS idx_spec_relations_unresolved
    ON spec_relations(specification_ref, link_selector)
    WHERE target_object_id IS NULL AND target_float_id IS NULL;

-- === spec_attribute_values ===

-- EAV pivot and attribute validation: owner + attribute name
-- Serves: WHERE owner_object_id = ? AND name = ? (EAV pivot, proof views)
--         WHERE owner_object_id = ? (attribute listing, type resolution)
-- Note: left-prefix covers owner_object_id-only lookups too
CREATE INDEX IF NOT EXISTS idx_spec_attr_owner_name
    ON spec_attribute_values(owner_object_id, name);

-- Owner float lookups: float attribute queries
-- Serves: WHERE owner_float_id = ? (float attribute listing)
CREATE INDEX IF NOT EXISTS idx_spec_attribute_values_owner_flt
    ON spec_attribute_values(owner_float_id);

-- Specification-scoped queries: FTS indexing, bulk operations
-- Serves: WHERE specification_ref = ? (FTS indexing, batch queries)
CREATE INDEX IF NOT EXISTS idx_spec_attribute_values_spec
    ON spec_attribute_values(specification_ref);

-- === spec_views ===

-- View materialization: spec + type with file ordering
-- Serves: WHERE specification_ref = ? AND view_type_ref = ? ORDER BY file_seq
CREATE INDEX IF NOT EXISTS idx_spec_views_spec_type
    ON spec_views(specification_ref, view_type_ref, file_seq);
]=]

return M
