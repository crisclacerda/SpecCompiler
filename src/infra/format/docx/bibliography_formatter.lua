---Config-driven bibliography formatting for DOCX postprocessors.
---Handles bibliography heading insertion and entry styling.
---
---Finds the "refs" bookmark (generated by Pandoc Citeproc), optionally inserts
---a page break and heading before it, and applies a paragraph style to all
---bibliography entries within the bookmark range.
---
---@module bibliography_formatter

local xml = require("infra.format.xml")
local M = {}

-- ============================================================================
-- Internal helpers
-- ============================================================================

---Check if a body-level node is a w:bookmarkStart with name="refs".
---@param node table DOM element node
---@return boolean
local function is_refs_bookmark_start(node)
    if node.name == "bookmarkStart" or node.name == "w:bookmarkStart" then
        return xml.get_attr(node, "w:name") == "refs"
    end
    return false
end

---Check if a body-level node is a w:bookmarkEnd matching a given ID.
---@param node table DOM element node
---@param id string Bookmark ID to match
---@return boolean
local function is_refs_bookmark_end(node, id)
    if node.name == "bookmarkEnd" or node.name == "w:bookmarkEnd" then
        return xml.get_attr(node, "w:id") == id
    end
    return false
end

---Check if a node is a paragraph element (w:p or p).
---@param node table DOM element node
---@return boolean
local function is_paragraph(node)
    return node.name == "w:p" or node.name == "p"
end

---Scan body children to find the start and end indices of the refs bookmark range.
---Handles bookmarks at the top level and nested within paragraphs.
---@param kids table Array of body child nodes
---@param refs_id string The w:id of the refs bookmarkStart
---@return number|nil refs_start_idx Index of the node containing or being the bookmarkStart
---@return number|nil refs_end_idx Index of the node containing or being the bookmarkEnd
local function find_refs_range(kids, refs_id)
    local refs_start_idx = nil
    local refs_end_idx = nil

    -- Pass 1: scan top-level bookmark nodes and nested bookmarks in paragraphs
    for i, node in ipairs(kids) do
        if node.type == "element" then
            -- Top-level bookmarkStart
            if is_refs_bookmark_start(node) then
                refs_start_idx = i
            -- Top-level bookmarkEnd
            elseif is_refs_bookmark_end(node, refs_id) then
                refs_end_idx = i
                break
            -- Paragraph: check for nested bookmarks
            elseif is_paragraph(node) and refs_start_idx then
                local nested_bm = xml.find_by_name(node, "w:bookmarkStart")
                for _, nbm in ipairs(nested_bm) do
                    if xml.get_attr(nbm, "w:name") == "refs" then
                        refs_start_idx = i
                        break
                    end
                end
                local nested_end = xml.find_by_name(node, "w:bookmarkEnd")
                for _, ne in ipairs(nested_end) do
                    if xml.get_attr(ne, "w:id") == refs_id then
                        refs_end_idx = i
                        break
                    end
                end
            end
        end
    end

    -- Pass 2: if start not found, try to find bookmark nested inside a paragraph
    if not refs_start_idx then
        for i, node in ipairs(kids) do
            if node.type == "element" and is_paragraph(node) then
                local nested_bm = xml.find_by_name(node, "w:bookmarkStart")
                for _, nbm in ipairs(nested_bm) do
                    if xml.get_attr(nbm, "w:name") == "refs" then
                        refs_start_idx = i
                        break
                    end
                end
                if refs_start_idx then break end
            end
        end
    end

    return refs_start_idx, refs_end_idx
end

---Check whether a paragraph's existing style should be skipped.
---@param pPr table The w:pPr element of the paragraph
---@param skip_styles table Array of style ID patterns to skip
---@return boolean true if the paragraph should be left unstyled
local function should_skip_style(pPr, skip_styles)
    local existing_style = xml.find_child(pPr, "w:pStyle")
    if not existing_style then
        return false
    end
    local style_val = xml.get_attr(existing_style, "w:val")
    if not style_val then
        return false
    end
    for _, pattern in ipairs(skip_styles) do
        -- Use string:match for prefix matching (e.g., "Heading" matches "Heading1")
        if style_val:match("^" .. pattern) then
            return true
        end
    end
    return false
end

-- ============================================================================
-- Public API
-- ============================================================================

---Format bibliography section in document.xml.
---Finds the "refs" bookmark (generated by Pandoc Citeproc), inserts a heading
---before it, and applies a paragraph style to bibliography entries.
---@param content string document.xml content
---@param config table Bibliography formatting configuration:
---   heading_text: string - Text for bibliography heading (e.g., "REFERENCES", "REFERÃŠNCIAS")
---   heading_style: string - Paragraph style for heading (e.g., "UnnumberedHeading")
---   entry_style: string - Paragraph style for entries (e.g., "Reference")
---   page_break_before: boolean - Insert page break before heading
---   skip_styles: table|nil - Array of style IDs to skip when styling entries
---@param log table Logger instance
---@return string Modified content
function M.format_bibliography(content, config, log)
    local doc = xml.parse(content)
    if not doc or not doc.root then
        log.warn('[BIBLIOGRAPHY] Failed to parse document.xml')
        return content
    end

    -- Find bookmarkStart with name="refs"
    local refs_bookmark = nil
    local bookmarks = xml.find_by_name(doc.root, "w:bookmarkStart")
    for _, bm in ipairs(bookmarks) do
        if xml.get_attr(bm, "w:name") == "refs" then
            refs_bookmark = bm
            break
        end
    end

    if not refs_bookmark then
        log.debug('[BIBLIOGRAPHY] No refs bookmark found, skipping bibliography formatting')
        return content
    end

    local refs_id = xml.get_attr(refs_bookmark, "w:id")
    if not refs_id then
        log.warn('[BIBLIOGRAPHY] refs bookmark has no id')
        return content
    end

    -- Find body element
    local body = xml.find_child(doc.root, "w:body")
    if not body then
        return content
    end

    local kids = body.kids or {}

    -- Locate bookmark range
    local refs_start_idx, refs_end_idx = find_refs_range(kids, refs_id)

    if not refs_start_idx then
        log.debug('[BIBLIOGRAPHY] Could not find refs bookmark position')
        return content
    end

    -- Insert heading and optional page break before the refs bookmark
    local inserted_count = 0

    if config.page_break_before then
        local page_break_para = xml.node("w:p", {}, {
            xml.node("w:r", {}, {
                xml.node("w:br", {["w:type"] = "page"})
            })
        })
        xml.insert_child(body, page_break_para, refs_start_idx)
        inserted_count = inserted_count + 1
    end

    if config.heading_text and config.heading_style then
        local heading_para = xml.node("w:p", {}, {
            xml.node("w:pPr", {}, {
                xml.node("w:pStyle", {["w:val"] = config.heading_style})
            }),
            xml.node("w:r", {}, {
                xml.node("w:t", {}, {xml.text(config.heading_text)})
            })
        })
        xml.insert_child(body, heading_para, refs_start_idx + inserted_count)
        inserted_count = inserted_count + 1
    end

    -- Adjust indices after insertions
    refs_start_idx = refs_start_idx + inserted_count
    if refs_end_idx then
        refs_end_idx = refs_end_idx + inserted_count
    end

    -- Refresh kids after insertions
    kids = body.kids or {}

    -- Style all paragraphs within the refs range
    local skip_styles = config.skip_styles or {}
    local styled_count = 0
    local end_idx = refs_end_idx or #kids

    for i = refs_start_idx + 1, end_idx do
        local node = kids[i]
        if node and node.type == "element" and is_paragraph(node) then
            local pPr = xml.find_child(node, "w:pPr")
            if not pPr then
                pPr = xml.node("w:pPr")
                xml.insert_child(node, pPr, 1)
            end

            -- Skip paragraphs with protected styles
            if should_skip_style(pPr, skip_styles) then
                goto continue
            end

            -- Apply entry style
            xml.replace_child(pPr, "w:pStyle",
                xml.node("w:pStyle", {["w:val"] = config.entry_style}))
            styled_count = styled_count + 1
        end
        ::continue::
    end

    if styled_count > 0 then
        log.debug('[BIBLIOGRAPHY] Applied %s style to %d bibliography entry(s)',
            config.entry_style, styled_count)
    end

    return xml.serialize(doc)
end

return M
